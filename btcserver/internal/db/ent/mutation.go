// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/generativelabs/btcserver/internal/db/ent/globalstate"
	"github.com/generativelabs/btcserver/internal/db/ent/predicate"
	"github.com/generativelabs/btcserver/internal/db/ent/stake"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeGlobalState = "GlobalState"
	TypeStake       = "Stake"
)

// GlobalStateMutation represents an operation that mutates the GlobalState nodes in the graph.
type GlobalStateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Key          *string
	_Value        *string
	_CreateAt     *int64
	add_CreateAt  *int64
	_UpdateAt     *int64
	add_UpdateAt  *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GlobalState, error)
	predicates    []predicate.GlobalState
}

var _ ent.Mutation = (*GlobalStateMutation)(nil)

// globalstateOption allows management of the mutation configuration using functional options.
type globalstateOption func(*GlobalStateMutation)

// newGlobalStateMutation creates new mutation for the GlobalState entity.
func newGlobalStateMutation(c config, op Op, opts ...globalstateOption) *GlobalStateMutation {
	m := &GlobalStateMutation{
		config:        c,
		op:            op,
		typ:           TypeGlobalState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGlobalStateID sets the ID field of the mutation.
func withGlobalStateID(id int) globalstateOption {
	return func(m *GlobalStateMutation) {
		var (
			err   error
			once  sync.Once
			value *GlobalState
		)
		m.oldValue = func(ctx context.Context) (*GlobalState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GlobalState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGlobalState sets the old GlobalState of the mutation.
func withGlobalState(node *GlobalState) globalstateOption {
	return func(m *GlobalStateMutation) {
		m.oldValue = func(context.Context) (*GlobalState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GlobalStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GlobalStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GlobalStateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GlobalStateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GlobalState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "Key" field.
func (m *GlobalStateMutation) SetKey(s string) {
	m._Key = &s
}

// Key returns the value of the "Key" field in the mutation.
func (m *GlobalStateMutation) Key() (r string, exists bool) {
	v := m._Key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "Key" field's value of the GlobalState entity.
// If the GlobalState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalStateMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "Key" field.
func (m *GlobalStateMutation) ResetKey() {
	m._Key = nil
}

// SetValue sets the "Value" field.
func (m *GlobalStateMutation) SetValue(s string) {
	m._Value = &s
}

// Value returns the value of the "Value" field in the mutation.
func (m *GlobalStateMutation) Value() (r string, exists bool) {
	v := m._Value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "Value" field's value of the GlobalState entity.
// If the GlobalState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalStateMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "Value" field.
func (m *GlobalStateMutation) ResetValue() {
	m._Value = nil
}

// SetCreateAt sets the "CreateAt" field.
func (m *GlobalStateMutation) SetCreateAt(i int64) {
	m._CreateAt = &i
	m.add_CreateAt = nil
}

// CreateAt returns the value of the "CreateAt" field in the mutation.
func (m *GlobalStateMutation) CreateAt() (r int64, exists bool) {
	v := m._CreateAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "CreateAt" field's value of the GlobalState entity.
// If the GlobalState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalStateMutation) OldCreateAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds i to the "CreateAt" field.
func (m *GlobalStateMutation) AddCreateAt(i int64) {
	if m.add_CreateAt != nil {
		*m.add_CreateAt += i
	} else {
		m.add_CreateAt = &i
	}
}

// AddedCreateAt returns the value that was added to the "CreateAt" field in this mutation.
func (m *GlobalStateMutation) AddedCreateAt() (r int64, exists bool) {
	v := m.add_CreateAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "CreateAt" field.
func (m *GlobalStateMutation) ResetCreateAt() {
	m._CreateAt = nil
	m.add_CreateAt = nil
}

// SetUpdateAt sets the "UpdateAt" field.
func (m *GlobalStateMutation) SetUpdateAt(i int64) {
	m._UpdateAt = &i
	m.add_UpdateAt = nil
}

// UpdateAt returns the value of the "UpdateAt" field in the mutation.
func (m *GlobalStateMutation) UpdateAt() (r int64, exists bool) {
	v := m._UpdateAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "UpdateAt" field's value of the GlobalState entity.
// If the GlobalState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalStateMutation) OldUpdateAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds i to the "UpdateAt" field.
func (m *GlobalStateMutation) AddUpdateAt(i int64) {
	if m.add_UpdateAt != nil {
		*m.add_UpdateAt += i
	} else {
		m.add_UpdateAt = &i
	}
}

// AddedUpdateAt returns the value that was added to the "UpdateAt" field in this mutation.
func (m *GlobalStateMutation) AddedUpdateAt() (r int64, exists bool) {
	v := m.add_UpdateAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "UpdateAt" field.
func (m *GlobalStateMutation) ResetUpdateAt() {
	m._UpdateAt = nil
	m.add_UpdateAt = nil
}

// Where appends a list predicates to the GlobalStateMutation builder.
func (m *GlobalStateMutation) Where(ps ...predicate.GlobalState) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GlobalStateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GlobalStateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GlobalState, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GlobalStateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GlobalStateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GlobalState).
func (m *GlobalStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GlobalStateMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Key != nil {
		fields = append(fields, globalstate.FieldKey)
	}
	if m._Value != nil {
		fields = append(fields, globalstate.FieldValue)
	}
	if m._CreateAt != nil {
		fields = append(fields, globalstate.FieldCreateAt)
	}
	if m._UpdateAt != nil {
		fields = append(fields, globalstate.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GlobalStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case globalstate.FieldKey:
		return m.Key()
	case globalstate.FieldValue:
		return m.Value()
	case globalstate.FieldCreateAt:
		return m.CreateAt()
	case globalstate.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GlobalStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case globalstate.FieldKey:
		return m.OldKey(ctx)
	case globalstate.FieldValue:
		return m.OldValue(ctx)
	case globalstate.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case globalstate.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown GlobalState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GlobalStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case globalstate.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case globalstate.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case globalstate.FieldCreateAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case globalstate.FieldUpdateAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown GlobalState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GlobalStateMutation) AddedFields() []string {
	var fields []string
	if m.add_CreateAt != nil {
		fields = append(fields, globalstate.FieldCreateAt)
	}
	if m.add_UpdateAt != nil {
		fields = append(fields, globalstate.FieldUpdateAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GlobalStateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case globalstate.FieldCreateAt:
		return m.AddedCreateAt()
	case globalstate.FieldUpdateAt:
		return m.AddedUpdateAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GlobalStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case globalstate.FieldCreateAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case globalstate.FieldUpdateAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown GlobalState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GlobalStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GlobalStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GlobalStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GlobalState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GlobalStateMutation) ResetField(name string) error {
	switch name {
	case globalstate.FieldKey:
		m.ResetKey()
		return nil
	case globalstate.FieldValue:
		m.ResetValue()
		return nil
	case globalstate.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case globalstate.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown GlobalState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GlobalStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GlobalStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GlobalStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GlobalStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GlobalStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GlobalStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GlobalStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GlobalState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GlobalStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GlobalState edge %s", name)
}

// StakeMutation represents an operation that mutates the Stake nodes in the graph.
type StakeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_Staker             *string
	_StakerPublicKey    *string
	_Tx                 *string
	_Start              *int64
	add_Start           *int64
	_Duration           *int64
	add_Duration        *int64
	_Deadline           *int64
	add_Deadline        *int64
	_ReleasingTime      *int64
	add_ReleasingTime   *int64
	_Amount             *int64
	add_Amount          *int64
	_RewardReceiver     *string
	_Reward             *int64
	add_Reward          *int64
	_FinalizedStatus    *int
	add_FinalizedStatus *int
	_ReleaseStatus      *int
	add_ReleaseStatus   *int
	_ReceiverSig        *string
	_Timestamp          *int64
	add_Timestamp       *int64
	_CreateAt           *int64
	add_CreateAt        *int64
	_UpdateAt           *int64
	add_UpdateAt        *int64
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Stake, error)
	predicates          []predicate.Stake
}

var _ ent.Mutation = (*StakeMutation)(nil)

// stakeOption allows management of the mutation configuration using functional options.
type stakeOption func(*StakeMutation)

// newStakeMutation creates new mutation for the Stake entity.
func newStakeMutation(c config, op Op, opts ...stakeOption) *StakeMutation {
	m := &StakeMutation{
		config:        c,
		op:            op,
		typ:           TypeStake,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStakeID sets the ID field of the mutation.
func withStakeID(id int) stakeOption {
	return func(m *StakeMutation) {
		var (
			err   error
			once  sync.Once
			value *Stake
		)
		m.oldValue = func(ctx context.Context) (*Stake, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stake.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStake sets the old Stake of the mutation.
func withStake(node *Stake) stakeOption {
	return func(m *StakeMutation) {
		m.oldValue = func(context.Context) (*Stake, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StakeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StakeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StakeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StakeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Stake.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStaker sets the "Staker" field.
func (m *StakeMutation) SetStaker(s string) {
	m._Staker = &s
}

// Staker returns the value of the "Staker" field in the mutation.
func (m *StakeMutation) Staker() (r string, exists bool) {
	v := m._Staker
	if v == nil {
		return
	}
	return *v, true
}

// OldStaker returns the old "Staker" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldStaker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStaker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStaker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaker: %w", err)
	}
	return oldValue.Staker, nil
}

// ResetStaker resets all changes to the "Staker" field.
func (m *StakeMutation) ResetStaker() {
	m._Staker = nil
}

// SetStakerPublicKey sets the "StakerPublicKey" field.
func (m *StakeMutation) SetStakerPublicKey(s string) {
	m._StakerPublicKey = &s
}

// StakerPublicKey returns the value of the "StakerPublicKey" field in the mutation.
func (m *StakeMutation) StakerPublicKey() (r string, exists bool) {
	v := m._StakerPublicKey
	if v == nil {
		return
	}
	return *v, true
}

// OldStakerPublicKey returns the old "StakerPublicKey" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldStakerPublicKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakerPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakerPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakerPublicKey: %w", err)
	}
	return oldValue.StakerPublicKey, nil
}

// ResetStakerPublicKey resets all changes to the "StakerPublicKey" field.
func (m *StakeMutation) ResetStakerPublicKey() {
	m._StakerPublicKey = nil
}

// SetTx sets the "Tx" field.
func (m *StakeMutation) SetTx(s string) {
	m._Tx = &s
}

// GetTx returns the value of the "Tx" field in the mutation.
func (m *StakeMutation) GetTx() (r string, exists bool) {
	v := m._Tx
	if v == nil {
		return
	}
	return *v, true
}

// OldTx returns the old "Tx" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldTx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTx: %w", err)
	}
	return oldValue.Tx, nil
}

// ResetTx resets all changes to the "Tx" field.
func (m *StakeMutation) ResetTx() {
	m._Tx = nil
}

// SetStart sets the "Start" field.
func (m *StakeMutation) SetStart(i int64) {
	m._Start = &i
	m.add_Start = nil
}

// Start returns the value of the "Start" field in the mutation.
func (m *StakeMutation) Start() (r int64, exists bool) {
	v := m._Start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "Start" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldStart(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds i to the "Start" field.
func (m *StakeMutation) AddStart(i int64) {
	if m.add_Start != nil {
		*m.add_Start += i
	} else {
		m.add_Start = &i
	}
}

// AddedStart returns the value that was added to the "Start" field in this mutation.
func (m *StakeMutation) AddedStart() (r int64, exists bool) {
	v := m.add_Start
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "Start" field.
func (m *StakeMutation) ResetStart() {
	m._Start = nil
	m.add_Start = nil
}

// SetDuration sets the "Duration" field.
func (m *StakeMutation) SetDuration(i int64) {
	m._Duration = &i
	m.add_Duration = nil
}

// Duration returns the value of the "Duration" field in the mutation.
func (m *StakeMutation) Duration() (r int64, exists bool) {
	v := m._Duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "Duration" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "Duration" field.
func (m *StakeMutation) AddDuration(i int64) {
	if m.add_Duration != nil {
		*m.add_Duration += i
	} else {
		m.add_Duration = &i
	}
}

// AddedDuration returns the value that was added to the "Duration" field in this mutation.
func (m *StakeMutation) AddedDuration() (r int64, exists bool) {
	v := m.add_Duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "Duration" field.
func (m *StakeMutation) ResetDuration() {
	m._Duration = nil
	m.add_Duration = nil
}

// SetDeadline sets the "Deadline" field.
func (m *StakeMutation) SetDeadline(i int64) {
	m._Deadline = &i
	m.add_Deadline = nil
}

// Deadline returns the value of the "Deadline" field in the mutation.
func (m *StakeMutation) Deadline() (r int64, exists bool) {
	v := m._Deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "Deadline" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldDeadline(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// AddDeadline adds i to the "Deadline" field.
func (m *StakeMutation) AddDeadline(i int64) {
	if m.add_Deadline != nil {
		*m.add_Deadline += i
	} else {
		m.add_Deadline = &i
	}
}

// AddedDeadline returns the value that was added to the "Deadline" field in this mutation.
func (m *StakeMutation) AddedDeadline() (r int64, exists bool) {
	v := m.add_Deadline
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeadline resets all changes to the "Deadline" field.
func (m *StakeMutation) ResetDeadline() {
	m._Deadline = nil
	m.add_Deadline = nil
}

// SetReleasingTime sets the "ReleasingTime" field.
func (m *StakeMutation) SetReleasingTime(i int64) {
	m._ReleasingTime = &i
	m.add_ReleasingTime = nil
}

// ReleasingTime returns the value of the "ReleasingTime" field in the mutation.
func (m *StakeMutation) ReleasingTime() (r int64, exists bool) {
	v := m._ReleasingTime
	if v == nil {
		return
	}
	return *v, true
}

// OldReleasingTime returns the old "ReleasingTime" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldReleasingTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleasingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleasingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleasingTime: %w", err)
	}
	return oldValue.ReleasingTime, nil
}

// AddReleasingTime adds i to the "ReleasingTime" field.
func (m *StakeMutation) AddReleasingTime(i int64) {
	if m.add_ReleasingTime != nil {
		*m.add_ReleasingTime += i
	} else {
		m.add_ReleasingTime = &i
	}
}

// AddedReleasingTime returns the value that was added to the "ReleasingTime" field in this mutation.
func (m *StakeMutation) AddedReleasingTime() (r int64, exists bool) {
	v := m.add_ReleasingTime
	if v == nil {
		return
	}
	return *v, true
}

// ResetReleasingTime resets all changes to the "ReleasingTime" field.
func (m *StakeMutation) ResetReleasingTime() {
	m._ReleasingTime = nil
	m.add_ReleasingTime = nil
}

// SetAmount sets the "Amount" field.
func (m *StakeMutation) SetAmount(i int64) {
	m._Amount = &i
	m.add_Amount = nil
}

// Amount returns the value of the "Amount" field in the mutation.
func (m *StakeMutation) Amount() (r int64, exists bool) {
	v := m._Amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "Amount" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "Amount" field.
func (m *StakeMutation) AddAmount(i int64) {
	if m.add_Amount != nil {
		*m.add_Amount += i
	} else {
		m.add_Amount = &i
	}
}

// AddedAmount returns the value that was added to the "Amount" field in this mutation.
func (m *StakeMutation) AddedAmount() (r int64, exists bool) {
	v := m.add_Amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "Amount" field.
func (m *StakeMutation) ResetAmount() {
	m._Amount = nil
	m.add_Amount = nil
}

// SetRewardReceiver sets the "RewardReceiver" field.
func (m *StakeMutation) SetRewardReceiver(s string) {
	m._RewardReceiver = &s
}

// RewardReceiver returns the value of the "RewardReceiver" field in the mutation.
func (m *StakeMutation) RewardReceiver() (r string, exists bool) {
	v := m._RewardReceiver
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardReceiver returns the old "RewardReceiver" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldRewardReceiver(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardReceiver is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardReceiver requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardReceiver: %w", err)
	}
	return oldValue.RewardReceiver, nil
}

// ResetRewardReceiver resets all changes to the "RewardReceiver" field.
func (m *StakeMutation) ResetRewardReceiver() {
	m._RewardReceiver = nil
}

// SetReward sets the "Reward" field.
func (m *StakeMutation) SetReward(i int64) {
	m._Reward = &i
	m.add_Reward = nil
}

// Reward returns the value of the "Reward" field in the mutation.
func (m *StakeMutation) Reward() (r int64, exists bool) {
	v := m._Reward
	if v == nil {
		return
	}
	return *v, true
}

// OldReward returns the old "Reward" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldReward(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReward is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReward requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReward: %w", err)
	}
	return oldValue.Reward, nil
}

// AddReward adds i to the "Reward" field.
func (m *StakeMutation) AddReward(i int64) {
	if m.add_Reward != nil {
		*m.add_Reward += i
	} else {
		m.add_Reward = &i
	}
}

// AddedReward returns the value that was added to the "Reward" field in this mutation.
func (m *StakeMutation) AddedReward() (r int64, exists bool) {
	v := m.add_Reward
	if v == nil {
		return
	}
	return *v, true
}

// ResetReward resets all changes to the "Reward" field.
func (m *StakeMutation) ResetReward() {
	m._Reward = nil
	m.add_Reward = nil
}

// SetFinalizedStatus sets the "FinalizedStatus" field.
func (m *StakeMutation) SetFinalizedStatus(i int) {
	m._FinalizedStatus = &i
	m.add_FinalizedStatus = nil
}

// FinalizedStatus returns the value of the "FinalizedStatus" field in the mutation.
func (m *StakeMutation) FinalizedStatus() (r int, exists bool) {
	v := m._FinalizedStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalizedStatus returns the old "FinalizedStatus" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldFinalizedStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinalizedStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinalizedStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalizedStatus: %w", err)
	}
	return oldValue.FinalizedStatus, nil
}

// AddFinalizedStatus adds i to the "FinalizedStatus" field.
func (m *StakeMutation) AddFinalizedStatus(i int) {
	if m.add_FinalizedStatus != nil {
		*m.add_FinalizedStatus += i
	} else {
		m.add_FinalizedStatus = &i
	}
}

// AddedFinalizedStatus returns the value that was added to the "FinalizedStatus" field in this mutation.
func (m *StakeMutation) AddedFinalizedStatus() (r int, exists bool) {
	v := m.add_FinalizedStatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetFinalizedStatus resets all changes to the "FinalizedStatus" field.
func (m *StakeMutation) ResetFinalizedStatus() {
	m._FinalizedStatus = nil
	m.add_FinalizedStatus = nil
}

// SetReleaseStatus sets the "ReleaseStatus" field.
func (m *StakeMutation) SetReleaseStatus(i int) {
	m._ReleaseStatus = &i
	m.add_ReleaseStatus = nil
}

// ReleaseStatus returns the value of the "ReleaseStatus" field in the mutation.
func (m *StakeMutation) ReleaseStatus() (r int, exists bool) {
	v := m._ReleaseStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseStatus returns the old "ReleaseStatus" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldReleaseStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseStatus: %w", err)
	}
	return oldValue.ReleaseStatus, nil
}

// AddReleaseStatus adds i to the "ReleaseStatus" field.
func (m *StakeMutation) AddReleaseStatus(i int) {
	if m.add_ReleaseStatus != nil {
		*m.add_ReleaseStatus += i
	} else {
		m.add_ReleaseStatus = &i
	}
}

// AddedReleaseStatus returns the value that was added to the "ReleaseStatus" field in this mutation.
func (m *StakeMutation) AddedReleaseStatus() (r int, exists bool) {
	v := m.add_ReleaseStatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetReleaseStatus resets all changes to the "ReleaseStatus" field.
func (m *StakeMutation) ResetReleaseStatus() {
	m._ReleaseStatus = nil
	m.add_ReleaseStatus = nil
}

// SetReceiverSig sets the "ReceiverSig" field.
func (m *StakeMutation) SetReceiverSig(s string) {
	m._ReceiverSig = &s
}

// ReceiverSig returns the value of the "ReceiverSig" field in the mutation.
func (m *StakeMutation) ReceiverSig() (r string, exists bool) {
	v := m._ReceiverSig
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverSig returns the old "ReceiverSig" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldReceiverSig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverSig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverSig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverSig: %w", err)
	}
	return oldValue.ReceiverSig, nil
}

// ResetReceiverSig resets all changes to the "ReceiverSig" field.
func (m *StakeMutation) ResetReceiverSig() {
	m._ReceiverSig = nil
}

// SetTimestamp sets the "Timestamp" field.
func (m *StakeMutation) SetTimestamp(i int64) {
	m._Timestamp = &i
	m.add_Timestamp = nil
}

// Timestamp returns the value of the "Timestamp" field in the mutation.
func (m *StakeMutation) Timestamp() (r int64, exists bool) {
	v := m._Timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "Timestamp" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldTimestamp(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// AddTimestamp adds i to the "Timestamp" field.
func (m *StakeMutation) AddTimestamp(i int64) {
	if m.add_Timestamp != nil {
		*m.add_Timestamp += i
	} else {
		m.add_Timestamp = &i
	}
}

// AddedTimestamp returns the value that was added to the "Timestamp" field in this mutation.
func (m *StakeMutation) AddedTimestamp() (r int64, exists bool) {
	v := m.add_Timestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimestamp resets all changes to the "Timestamp" field.
func (m *StakeMutation) ResetTimestamp() {
	m._Timestamp = nil
	m.add_Timestamp = nil
}

// SetCreateAt sets the "CreateAt" field.
func (m *StakeMutation) SetCreateAt(i int64) {
	m._CreateAt = &i
	m.add_CreateAt = nil
}

// CreateAt returns the value of the "CreateAt" field in the mutation.
func (m *StakeMutation) CreateAt() (r int64, exists bool) {
	v := m._CreateAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "CreateAt" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldCreateAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds i to the "CreateAt" field.
func (m *StakeMutation) AddCreateAt(i int64) {
	if m.add_CreateAt != nil {
		*m.add_CreateAt += i
	} else {
		m.add_CreateAt = &i
	}
}

// AddedCreateAt returns the value that was added to the "CreateAt" field in this mutation.
func (m *StakeMutation) AddedCreateAt() (r int64, exists bool) {
	v := m.add_CreateAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "CreateAt" field.
func (m *StakeMutation) ResetCreateAt() {
	m._CreateAt = nil
	m.add_CreateAt = nil
}

// SetUpdateAt sets the "UpdateAt" field.
func (m *StakeMutation) SetUpdateAt(i int64) {
	m._UpdateAt = &i
	m.add_UpdateAt = nil
}

// UpdateAt returns the value of the "UpdateAt" field in the mutation.
func (m *StakeMutation) UpdateAt() (r int64, exists bool) {
	v := m._UpdateAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "UpdateAt" field's value of the Stake entity.
// If the Stake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakeMutation) OldUpdateAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds i to the "UpdateAt" field.
func (m *StakeMutation) AddUpdateAt(i int64) {
	if m.add_UpdateAt != nil {
		*m.add_UpdateAt += i
	} else {
		m.add_UpdateAt = &i
	}
}

// AddedUpdateAt returns the value that was added to the "UpdateAt" field in this mutation.
func (m *StakeMutation) AddedUpdateAt() (r int64, exists bool) {
	v := m.add_UpdateAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "UpdateAt" field.
func (m *StakeMutation) ResetUpdateAt() {
	m._UpdateAt = nil
	m.add_UpdateAt = nil
}

// Where appends a list predicates to the StakeMutation builder.
func (m *StakeMutation) Where(ps ...predicate.Stake) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StakeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StakeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Stake, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StakeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StakeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Stake).
func (m *StakeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StakeMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m._Staker != nil {
		fields = append(fields, stake.FieldStaker)
	}
	if m._StakerPublicKey != nil {
		fields = append(fields, stake.FieldStakerPublicKey)
	}
	if m._Tx != nil {
		fields = append(fields, stake.FieldTx)
	}
	if m._Start != nil {
		fields = append(fields, stake.FieldStart)
	}
	if m._Duration != nil {
		fields = append(fields, stake.FieldDuration)
	}
	if m._Deadline != nil {
		fields = append(fields, stake.FieldDeadline)
	}
	if m._ReleasingTime != nil {
		fields = append(fields, stake.FieldReleasingTime)
	}
	if m._Amount != nil {
		fields = append(fields, stake.FieldAmount)
	}
	if m._RewardReceiver != nil {
		fields = append(fields, stake.FieldRewardReceiver)
	}
	if m._Reward != nil {
		fields = append(fields, stake.FieldReward)
	}
	if m._FinalizedStatus != nil {
		fields = append(fields, stake.FieldFinalizedStatus)
	}
	if m._ReleaseStatus != nil {
		fields = append(fields, stake.FieldReleaseStatus)
	}
	if m._ReceiverSig != nil {
		fields = append(fields, stake.FieldReceiverSig)
	}
	if m._Timestamp != nil {
		fields = append(fields, stake.FieldTimestamp)
	}
	if m._CreateAt != nil {
		fields = append(fields, stake.FieldCreateAt)
	}
	if m._UpdateAt != nil {
		fields = append(fields, stake.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StakeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stake.FieldStaker:
		return m.Staker()
	case stake.FieldStakerPublicKey:
		return m.StakerPublicKey()
	case stake.FieldTx:
		return m.GetTx()
	case stake.FieldStart:
		return m.Start()
	case stake.FieldDuration:
		return m.Duration()
	case stake.FieldDeadline:
		return m.Deadline()
	case stake.FieldReleasingTime:
		return m.ReleasingTime()
	case stake.FieldAmount:
		return m.Amount()
	case stake.FieldRewardReceiver:
		return m.RewardReceiver()
	case stake.FieldReward:
		return m.Reward()
	case stake.FieldFinalizedStatus:
		return m.FinalizedStatus()
	case stake.FieldReleaseStatus:
		return m.ReleaseStatus()
	case stake.FieldReceiverSig:
		return m.ReceiverSig()
	case stake.FieldTimestamp:
		return m.Timestamp()
	case stake.FieldCreateAt:
		return m.CreateAt()
	case stake.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StakeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stake.FieldStaker:
		return m.OldStaker(ctx)
	case stake.FieldStakerPublicKey:
		return m.OldStakerPublicKey(ctx)
	case stake.FieldTx:
		return m.OldTx(ctx)
	case stake.FieldStart:
		return m.OldStart(ctx)
	case stake.FieldDuration:
		return m.OldDuration(ctx)
	case stake.FieldDeadline:
		return m.OldDeadline(ctx)
	case stake.FieldReleasingTime:
		return m.OldReleasingTime(ctx)
	case stake.FieldAmount:
		return m.OldAmount(ctx)
	case stake.FieldRewardReceiver:
		return m.OldRewardReceiver(ctx)
	case stake.FieldReward:
		return m.OldReward(ctx)
	case stake.FieldFinalizedStatus:
		return m.OldFinalizedStatus(ctx)
	case stake.FieldReleaseStatus:
		return m.OldReleaseStatus(ctx)
	case stake.FieldReceiverSig:
		return m.OldReceiverSig(ctx)
	case stake.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case stake.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case stake.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown Stake field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StakeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stake.FieldStaker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaker(v)
		return nil
	case stake.FieldStakerPublicKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakerPublicKey(v)
		return nil
	case stake.FieldTx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTx(v)
		return nil
	case stake.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case stake.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case stake.FieldDeadline:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	case stake.FieldReleasingTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleasingTime(v)
		return nil
	case stake.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case stake.FieldRewardReceiver:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardReceiver(v)
		return nil
	case stake.FieldReward:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReward(v)
		return nil
	case stake.FieldFinalizedStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalizedStatus(v)
		return nil
	case stake.FieldReleaseStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseStatus(v)
		return nil
	case stake.FieldReceiverSig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverSig(v)
		return nil
	case stake.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case stake.FieldCreateAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case stake.FieldUpdateAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown Stake field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StakeMutation) AddedFields() []string {
	var fields []string
	if m.add_Start != nil {
		fields = append(fields, stake.FieldStart)
	}
	if m.add_Duration != nil {
		fields = append(fields, stake.FieldDuration)
	}
	if m.add_Deadline != nil {
		fields = append(fields, stake.FieldDeadline)
	}
	if m.add_ReleasingTime != nil {
		fields = append(fields, stake.FieldReleasingTime)
	}
	if m.add_Amount != nil {
		fields = append(fields, stake.FieldAmount)
	}
	if m.add_Reward != nil {
		fields = append(fields, stake.FieldReward)
	}
	if m.add_FinalizedStatus != nil {
		fields = append(fields, stake.FieldFinalizedStatus)
	}
	if m.add_ReleaseStatus != nil {
		fields = append(fields, stake.FieldReleaseStatus)
	}
	if m.add_Timestamp != nil {
		fields = append(fields, stake.FieldTimestamp)
	}
	if m.add_CreateAt != nil {
		fields = append(fields, stake.FieldCreateAt)
	}
	if m.add_UpdateAt != nil {
		fields = append(fields, stake.FieldUpdateAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StakeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stake.FieldStart:
		return m.AddedStart()
	case stake.FieldDuration:
		return m.AddedDuration()
	case stake.FieldDeadline:
		return m.AddedDeadline()
	case stake.FieldReleasingTime:
		return m.AddedReleasingTime()
	case stake.FieldAmount:
		return m.AddedAmount()
	case stake.FieldReward:
		return m.AddedReward()
	case stake.FieldFinalizedStatus:
		return m.AddedFinalizedStatus()
	case stake.FieldReleaseStatus:
		return m.AddedReleaseStatus()
	case stake.FieldTimestamp:
		return m.AddedTimestamp()
	case stake.FieldCreateAt:
		return m.AddedCreateAt()
	case stake.FieldUpdateAt:
		return m.AddedUpdateAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StakeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stake.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case stake.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case stake.FieldDeadline:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeadline(v)
		return nil
	case stake.FieldReleasingTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReleasingTime(v)
		return nil
	case stake.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case stake.FieldReward:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReward(v)
		return nil
	case stake.FieldFinalizedStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFinalizedStatus(v)
		return nil
	case stake.FieldReleaseStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReleaseStatus(v)
		return nil
	case stake.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimestamp(v)
		return nil
	case stake.FieldCreateAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case stake.FieldUpdateAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown Stake numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StakeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StakeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StakeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Stake nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StakeMutation) ResetField(name string) error {
	switch name {
	case stake.FieldStaker:
		m.ResetStaker()
		return nil
	case stake.FieldStakerPublicKey:
		m.ResetStakerPublicKey()
		return nil
	case stake.FieldTx:
		m.ResetTx()
		return nil
	case stake.FieldStart:
		m.ResetStart()
		return nil
	case stake.FieldDuration:
		m.ResetDuration()
		return nil
	case stake.FieldDeadline:
		m.ResetDeadline()
		return nil
	case stake.FieldReleasingTime:
		m.ResetReleasingTime()
		return nil
	case stake.FieldAmount:
		m.ResetAmount()
		return nil
	case stake.FieldRewardReceiver:
		m.ResetRewardReceiver()
		return nil
	case stake.FieldReward:
		m.ResetReward()
		return nil
	case stake.FieldFinalizedStatus:
		m.ResetFinalizedStatus()
		return nil
	case stake.FieldReleaseStatus:
		m.ResetReleaseStatus()
		return nil
	case stake.FieldReceiverSig:
		m.ResetReceiverSig()
		return nil
	case stake.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case stake.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case stake.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown Stake field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StakeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StakeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StakeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StakeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StakeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StakeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StakeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Stake unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StakeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Stake edge %s", name)
}
